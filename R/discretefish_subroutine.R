#' Run discrete choice model
#'
#' Subroutine to run chosen discrete choice model. Function pulls necessary data 
#' generated in \code{\link{make_model_design}} and loops through model design 
#' choices and expected catch cases. Output is saved to the FishSET database.
#'
#' @param project  String, name of project.
#' @param run String, how models should be run. \code{'new'} will only run models
#'   that exist in the model design file but not in the model output table. \code{'all'}
#'   will run all models in the model design file, replacing existing model output. 
#'   The third option is to enter a vector of model names to run (use 
#'   \code{model_names()} to see current model names). 
#'   If the specified model already has output it will be replaced.  
#' @param select.model Return an interactive data table that allows users to 
#'   select and save table of best models based on measures of fit.
#' @param explorestarts Logical, should starting parameters value space be explored? 
#'   Set to \code{TRUE} if unsure of the number of starting parameter values to 
#'   include or of reasonable starting parameters values. Better starting parameter 
#'   values can help with model convergence.
#' @param breakearly Logical, if \code{explorestarts = TRUE}, should the first set 
#'   of starting parameter values that returns a valid (numeric) loglikelihood 
#'   value be returned (\code{TRUE}) or should the entire parameter space be considered 
#'   and the set of starting parameter values that return the lowest loglikelihood 
#'   value be returned (\code{FALSE}).
#' @param space Specify if \code{explorestarts = TRUE}. List of length 1 or length 
#'   equal to the number of models to be evaluated. \code{space} is the number of 
#'   starting value permutations to test (the size of the space to explore). The 
#'   greater the \code{dev} argument, the larger the \code{space} argument should be.
#' @param dev Specify if \code{explorestarts = TRUE}. List of length 1 or length 
#'   equal to the number of models to be evaluated. \code{dev} refers to how far 
#'   to deviate from the average parameter values when exploring (random normal 
#'   deviates). The less certain the average parameters are, the greater the 
#'   \code{dev} argument should be.
#' @param use.scalers Logical, should data be normalized? Defaults to \code{FALSE}. 
#'   Rescaling factors are the mean of the numeric vector unless specified with 
#'   \code{scaler.func}.
#' @param scaler.func Function to calculate rescaling factors. Can be a generic 
#'   function, such as mean, or a user-defined function. User-defined functions 
#'   must be specified as \code{scaler.fun = function(x, FUN = sd) 2*FUN(x)}. 
#'   This example returns two times the standard deviation of \code{x}.
#' @param CV Logical, \code{CV = TRUE} when running \code{discretefish_subroutine} for k-fold cross validation,
#' and the default value is \code{CV = FALSE}.

#' @export discretefish_subroutine
#' @importFrom DBI dbExecute dbWriteTable dbExistsTable dbReadTable dbGetQuery dbDisconnect
#' @importFrom DT datatable JS DTOutput
#' @importFrom stats optim
#' @import shiny
#' @details Runs through model design choices generated by \code{\link{make_model_design}} 
#'   and stored as `ModelInputData` in FishSET database.  Data matrix is created 
#'   in \code{\link{create_model_input}}. Required data, optional data, and details 
#'   on likelihood functions are outlined in \code{\link{make_model_design}}. \cr\cr
#'
#' Likelihood-specific initial parameter estimates: \cr
#' 
#' \enumerate{
#'  \item{\strong{Conditional logit likelihood (\code{\link{logit_c}})}\cr
#'    Starting parameter values takes the order of: c([alternative-specific parameters],  [travel-distance parameters]).
#'    The alternative-specific parameters and travel-distance parameters are of length (# of alternative-specific variables) and (# of
#'    travel-distance variables) respectively.} 
#'  \item{\strong{Zonal logit with area specific constants (\code{\link{logit_zonal}})} \cr
#'    Starting parameters takes the order of: c([average-catch parameters], [travel-distance parameters]).
#'    The average-catch and travel-distance parameters are of length (# of average-catch variables)*(k-1) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices.}
#'  \item{\strong{Full information model with Dahl's correction function (\code{\link{logit_correction}})} \cr
#'    Starting parameter values takes the order of: c([marginal utility from catch], [catch-function parameters],
#'    [polynomial starting parameters], [travel-distance parameters], [catch sigma]).
#'    The number of polynomial interaction terms is currently set to 2, so given the chosen degree 'polyn' there should be
#'    \code{"(((polyn+1)*2)+2)*(k)"} polynomial starting parameters, where (k) equals the number of alternative fishing choices.
#'    The marginal utility from catch and catch sigma are of length equal to unity respectively. The catch-function and
#'    travel-distance parameters are of length (# of catch variables)*(k) and (# of cost variables) respectively.}
#'  \item{\strong{Expected profit model with normal catch function (\code{\link{epm_normal}})} \cr
#'    Starting parameters values take the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]).
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance
#'    variables) respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal
#'    to unity or length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length
#'    equal to unity.}
#'  \item{\strong{Expected profit model with Weibull catch function (\code{\link{epm_weibull}})} \cr
#'    Starting parameter values takes the order of: c([catch-function parameters], [travel-distance parameters], [catch sigma(s)], [scale parameter]).
#'    The catch-function and travel-distance parameters are of length (# of catch-function variables)*(k) and (# of travel-distance variables)
#'    respectively, where (k) equals the number of alternative fishing choices. The catch sigma(s) are either of length equal to unity or
#'    length (k) if the analyst is estimating location-specific catch sigma parameters. The scale parameter is of length equal to unity.}
#'  \item{\strong{Expected profit model with log-normal catch function (\code{\link{epm_lognormal}})} \cr
#'    Starting parameter values takes the order of: c([catch-function parameters], [travel-distanceparameters],
#'    [catch sigma(s)], [scale parameter]).
#'    The catch-function and travel-distance parameters are of length (# of
#'    catch-function variables)*(k) and (# of travel-distance variables) respectively, where (k) equals the number of alternative fishing choices.
#'    The catch sigma(s) are either of length equal to unity or length (k) if the analyst is estimating location-specific catch sigma parameters.
#'    The scale parameter is of length equal to unity.}  
#'}
#'    \cr
#'    
#'    Model output are saved to the FishSET database and can be loaded to the console with:
#'    \tabular{rlll}{
#'    \code{\link{model_out_view}}: \tab model output including optimization information, standard errors, coefficients, and t- statistics. \cr
#'    \code{\link{model_params}}: \tab model estimates and standard error \cr
#'    \code{\link{model_fit}}: \tab model comparison metrics \cr
#'    \code{\link{globalcheck_view}}: \tab  model error message \cr
#'      }
#'    For obtaining catch, choice, distance, and otherdat data generated from \code{make_model_design} function.
#'    \code{ModelInputData} table will be pulled from FishSET database.
#'
#' @return
#' \tabular{rlll}{
#'   OutLogit: \tab [outmat1 se1 EPM2] (coefs, ses, tstats) \cr
#'   optoutput: \tab optimization information \cr
#'   seoumat2: \tab ses \cr
#'   MCM: \tab Model Comparison metrics \cr
#' }
#' @examples
#' \dontrun{
#' results <- discretefish_subroutine("pcod", run = 'all', select.model = TRUE)
#' }
#'
discretefish_subroutine <- function(project,
                                    run = 'new',
                                    select.model = FALSE,
                                    explorestarts = TRUE,
                                    breakearly = TRUE,
                                    space = NULL,
                                    dev = NULL,
                                    use.scalers = FALSE,
                                    scaler.func = NULL,
                                    CV = FALSE) {
    
  if (!isRunning()) { # if run in console
    check <- checklist(project)
    end <- any(vapply(check, function(x) x$pass == FALSE, logical(1)))
    
    if (end) stop("Model checklist incomplete.", call. = FALSE)
  }

  # Call in datasets
  if (table_exists(paste0(project, "ModelInputData"), project)) {
    
    mdf <- model_design_list(project)
    
  } else {
    
    stop('Model input table does not exist.', call. = FALSE)
  }

  # model names from MDF
  mdf_n <- model_names(project)
  
  # full names (as they would be in MOT)
  mdf_nn <- lapply(mdf, function(x) {
    
    if (!is.null(x$expectcatchmodels)) {
      # if exp matrices included, created full model name
      vapply(x$expectcatchmodels, function(y) {
        
        paste0(c(x$mod.name, y), collapse = '.')
      }, character(1))
      # otherwise, return unnested name
    } else x$mod.name
  })
  
  names(mdf_nn) <- mdf_n
  
  mot_exists <- table_exists(paste0(project, 'ModelOut'), project)
  
  if ('new' %in% run) { # run new models
    
    if (mot_exists) {
      
      mot <- model_out_view(project)
      mot_n <- vapply(mot, function(x) x$name, character(1))
      
      is_new_mod <- vapply(mdf_n, function(x) {
        
        all(!mdf_nn[[x]] %in% mot_n)
      }, logical(1))
      
      if (any(is_new_mod)) {
        
        mdf <- mdf[which(is_new_mod)]
        
      } else {
        
        stop('No new models to run. To rerun models, set run = "all".', call. = FALSE)
      }
    } # else run all models 
    
  } else if (!'all' %in% run) { # run select models
    
    if (all(!run %in% mdf_n)) {
      
      stop('The following models are not in the model design file: ',
           paste0(run[!run %in% mdf_n], collapse = ', '), 
           call. = FALSE)
    }
    
    mdf <- mdf[which(mdf_n %in% run)]
    
  } # else run all models
  
  ModelOut <- list()
  
  for (i in seq_along(mdf)) { # loop thru each model

    x <- mdf[[i]]
    
    length.exp.names <-length(x$expectcatchmodels)
    
    if (length.exp.names == 0) length.exp.names <- 1
    
    # data matrix ----
    # loop thru expected catch matrices (loops once if no matrix)
    
    for (j in seq_len(length.exp.names)) {
      
      if (is_value_empty(unlist(x$expectcatchmodels))) {
        
        exp.names <- NULL
        
      } else {
        
        exp.names <- x$expectcatchmodels[[j]]
      }
      
      # IMPORTANT NOTE: datamatrix$d is shifted and sorted for choice possibilities AND distances even though column names for distances are not sorted.
      datamatrix <- create_model_input(project = project, x = x, 
                                       mod.name = x$mod.name, 
                                       use.scalers = use.scalers, 
                                       scaler.func = scaler.func, 
                                       expected.catch = x$gridVaryingVariables, 
                                       exp.names = exp.names)
        
      if (is.factor(x$optimOpt)) {
        
        opt <- as.numeric(unlist(strsplit(as.character(x$optimOpt), " ")))
        
      } else if (is.list(x$optimOpt)) {
        
        opt <- as.numeric(unlist(x$optimOpt))
        
      } else {
        
        opt <- as.numeric(unlist(strsplit(as.character(x$optimOpt), " ")))
      }
    
      if (is.factor(x$initparams)) {
        
        starts2 <- as.numeric(unlist(strsplit(as.character(x$initparams), ","))) # inits
        
      } else if (is.list(x$initparams)) {
        
        starts2 <- unlist(x$initparams)
        
      } else {
        
        starts2 <-as.numeric(unlist(strsplit(as.character(x$initparams), ","))) # inits
      }
      
      errorExplain <- NULL
      OutLogit <- NULL
      optoutput <- NULL
      seoutmat2 <- NULL
      MCM <- NULL
      H1 <- NULL
      fr <- x$likelihood # func  #e.g. logit_c
      fr.name <- match.fun(find_original_name(match.fun(as.character(fr))))
    
      # Number of inits ----
      gridNum <- length(datamatrix$otherdat$griddat)
      intNum <-  length(datamatrix$otherdat$intdat)
      
      if (fr == 'logit_c') {
        
        numInits <- gridNum + intNum
        
      } else if (fr == 'logit_zonal') {
        
        numInits <- gridNum * (max(datamatrix$choice) - 1) + intNum
        
      } else if (fr == 'logit_correction') {
        
        numInits <- gridNum * max(datamatrix$choice) + intNum + 
          ((((as.numeric(mdf[[i]]$polyn)+1)*2)+2)*max(datamatrix$choice)) +1+1
        
      } else {
        
        numInits <- gridNum * max(datamatrix$choice) + intNum + 2
      }
      
      if (numInits != length(starts2)) {
        
        if (length(starts2) == 1) {
          
          starts2 <- rep(starts2, numInits)
          
        } else if (numInits > length(starts2)) { # TODO: check if this is okay
          
          starts2 <- c(starts2, rep(1, (numInits - length(starts2))))
          message(numInits, ' initial parameter values should be specified')
          
        } else if (numInits < length(starts2)) { # TODO: check if this is okay
          
          if(length(starts2) == (numInits + x$alts - 1)) {
            # do nothing and keep starts
            
          } else {
            starts2 <- starts2[1:numInits]
            message(numInits, ' (or ', numInits + x$alts - 1, ' for some EPMs) initial parameter values should be specified')  
          }
        } 
      }

      # Explore starting parameters ----
      if (explorestarts) {
        sp <- if (is_empty(space[i])) 10 else space[i]
        devr <- if (is_empty(dev[i])) 5 else dev[i] 
        
        starts2 <- explore_startparams_discrete(space = sp, dev = devr, 
                                                breakearly = breakearly, 
                                                startsr = starts2, fr = fr, 
                                                d = datamatrix$d, 
                                                otherdat = datamatrix$otherdat, 
                                                choice = datamatrix$choice, 
                                                project = project)
      }
      
      # likelihood ----
      LL_start <- fr.name(starts3 = starts2, dat = datamatrix$d, otherdat = datamatrix$otherdat, 
                          alts = max(datamatrix$choice), project = project, 
                          expname = datamatrix$expname, mod.name = as.character(datamatrix$mod.name))
      
      if (is.null(LL_start) || is.nan(LL_start) || is.infinite(LL_start)) {
        # haven't checked what happens when error yet
        errorExplain <- "Initial function results bad (Nan, Inf, or undefined), check 'LDGlobalCheck'"
        cat("Initial function results bad (Nan, Inf, or undefined), check 'LDGlobalCheck'")
        next
      }

      # optim ----
      res <- c()
      mIter <- opt[1] # should add something to default options here if not specified
      relTolX <- opt[2]
      reportfreq <- opt[3]
      detailreport <- opt[4]
      
      controlin <- list(trace = detailreport, maxit = mIter, reltol = relTolX, REPORT = reportfreq)
      
      # track run time
      mod_time <- system.time({
        res <- 
          tryCatch({
            
            stats::optim(starts2, fr.name,
                         dat = datamatrix$d, otherdat = datamatrix$otherdat,
                         alts = max(datamatrix$choice),
                         method = as.character(mdf[[i]][['methodname']]),
                         control = controlin, hessian = TRUE, project = project,
                         expname = datamatrix$expname,
                         mod.name = as.character(unlist(mdf[[i]][['mod.name']])))
        },
        
        error = function(e) {
          
          return("Optimization error, check 'LDGlobalCheck'")
        })
      })[["elapsed"]]
      
      if(isRunning()){
        incProgress(amount = 1/ ((length.exp.names + length(mdf)) * 2))
      }
      
      # save ld global check ----
      fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project = project))
      on.exit(DBI::dbDisconnect(fishset_db), add = TRUE)
      
      if(!CV){
        single_sql <- paste0(project, "LDGlobalCheck", format(Sys.Date(), format = "%Y%m%d"))
        second_sql <- paste("INSERT INTO", single_sql, "VALUES (:data)")
        
        if (table_exists(single_sql, project)) {
          
          empty_dat <- 
            is_empty(
              unlist(
                DBI::dbGetQuery(fishset_db, 
                                paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data
              )
            )
          
          if (any(empty_dat)) {
            
            table_remove(single_sql, project)
            LDGlobalCheck <- LDGlobalCheck
            
          } else {
            # TODO: overwrites model data if more than one expected catch matrix is used
            x_ldgcheck <- unserialize(DBI::dbGetQuery(fishset_db, 
                                                      paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
            table_remove(single_sql, project = project)
            LDGlobalCheck <- c(x_ldgcheck, LDGlobalCheck)
          }
        }
        
        ld_sql <- paste0("CREATE TABLE IF NOT EXISTS ", project, "LDGlobalCheck", 
                         format(Sys.Date(), format = "%Y%m%d"), "(data LDGlobalCheck)")
        
        DBI::dbExecute(fishset_db, ld_sql)
        DBI::dbExecute(fishset_db, second_sql, 
                       params = list(data = list(serialize(LDGlobalCheck, NULL))))
        
        
        if (res[[1]][1] == "Optimization error, check 'LDGlobalCheck'") {
          
          print(
            list(
              error = paste('optimization error for', mdf[[i]]$mod.name,
                            ', check LDGlobalCheck'),
              name = names(mdf[[i]][["gridVaryingVariables"]])[i], 
              errorExplain = res, OutLogit = OutLogit, optoutput = optoutput,
              seoutmat2 = seoutmat2, MCM = MCM, H1 = H1
            )
          )
          
          next
        }
      }
      
      q2 <- res[["par"]]
      LL <- res[["value"]]
      
      output <- list(
        counts = res[["counts"]], convergence = res[["convergence"]],
        optim_message = res[["message"]]
      )
      
      H <- res[["hessian"]]
  
      # Model comparison metrics (MCM) ----
      
      param <- length(starts2)
      obs <- nrow(datamatrix$dataCompile)
      AIC <- round(2 * param - 2 * LL, 3)
      
      AICc <- round(AIC + (2 * param * (param + 1)) / (obs - param - 1), 3)
      
      BIC <- round(-2 * LL + param * log(obs), 3)
      
      PseudoR2 <- round((LL_start - LL) / LL_start, 3)
      
      # if (!is.null(datamatrix$expname)) {
      #   
      #   modOutName <- paste0(c(mdf[[i]][["mod.name"]], datamatrix$expname), collapse = '.')
      # } else 
      modOutName <- mdf[[i]][["mod.name"]]
    
      mod.out <- data.frame(matrix(NA, nrow = 4, ncol = 1))
      mod.out[, 1] <- c(AIC, AICc, BIC, PseudoR2)
      rownames(mod.out) <- c("AIC", "AICc", "BIC", "PseudoR2")
      colnames(mod.out) <- modOutName

      if(!CV){
        mft_tab_nm <- paste0(project, "ModelFit")  
      } else {
        mft_tab_nm <- paste0(project, "ModelFitCV")  
      }
      
      if (table_exists(mft_tab_nm, project)) {
        
        mft <- model_fit(project, CV)
        
        if (!'new' %in% run) { # selected models
          # TODO: using name method below for all cases may be simpler
          mft[[modOutName]] <- mod.out[[modOutName]]
          DBI::dbWriteTable(fishset_db, mft_tab_nm, mft, overwrite = TRUE)
          
        } else {
          
          DBI::dbWriteTable(fishset_db, mft_tab_nm, cbind(mft, mod.out), overwrite = TRUE)
        }
        
      } else {
        
        DBI::dbWriteTable(fishset_db, mft_tab_nm, mod.out)
        mft <- model_fit(project, CV) # for use in model select app
      }
      
      ## Full model output ----
      MCM <- list(AIC = AIC, AICc = AICc, BIC = BIC, PseudoR2 = PseudoR2)
      
      single_mat_error <- "Error, singular, check 'LDGlobalCheck'"
      se_error <- "Cannot compute standard error. Check 'LDGlobalCheck'"
      
      if (is.null(H)) {
        
        print("Model error, check 'LDGlobalCheck'")
      
      } else {
        
        Htrial <- function(x) {
          
          tryCatch({
            
              solve(x)
            },
            
            error = function(e) {
              return(single_mat_error)
          })
        }
        
        print(Htrial(H))
        H1 <- Htrial(H)
        
        diagtrial <- function(x) {
          
          diagtrial <- tryCatch({
            
              diag(H1)
            },
            
            error = function(e) {
              return("Error, NAs, check 'LDGlobalCheck'")
            }
          )
          
          diagtrial
        }
        
        if (H1[1] != single_mat_error) {
          
          diag2 <- diagtrial(H1)
          print(diag2)
        }
        
        if (H1[1] != single_mat_error) {
          
          if (diag2[1] != "Error, NAs, check 'LDGlobalCheck'") {
            
            se2 <- tryCatch({
              
                sqrt(diag2)
              },
              
              warning = function(war) {
                
                print(se_error)
                sqrt(diag2)
              }
            )
            
          } else {
            
            warning = function(war) {
              
              print(se_error)
            }
          }
        }
       
        if (H1[1] != single_mat_error && se2[1]!= se_error) {
            
          seoutmat2 <- t(se2) # standard errors
          optoutput <- output # optimization info - counts, convergence, optimization error
          tLogit <- t(t(q2) / se2)
          OutLogit <- data.frame(estimate = q2, std_error = se2, t_value = tLogit)
          OutLogit <- round(OutLogit, 3)
          
        } else {
          
          outmat2 <- t(q2)
          OutLogit <- data.frame(estimate = round(q2, 3), std_error = NA, t_value = NA)
        }
        
        # TODO: make sure this works for each model type
        p_names <- unlist(lapply(mdf[[i]]$bCHeader[-1], names))
        grid_vars <- names(mdf[[i]]$bCHeader$gridVariablesInclude)
        ind_vars <- names(mdf[[i]]$bCHeader$indeVarsForModel)
        
        if(is_value_empty(x$expectcatchmodels)){
          ec_names <- NULL  
        } else {
          ec_names <- x$expectcatchmodels[[j]]
        }

        if (fr == "logit_zonal") {
          
          z_names <- sort(unique(mdf[[i]]$choice$choice))[-1]
          n1 <- unlist(lapply(grid_vars, function(x) as.character(interaction(x, z_names)))) 
          rownames(OutLogit) <- c(n1, ind_vars) 
          
        } else if (grepl("epm", fr)) {

          z_names <- sort(unique(mdf[[i]]$choice$choice))
          n1 <- unlist(lapply(grid_vars, function(x) as.character(interaction(x, z_names))))
          if((nrow(OutLogit) - length(n1) - length(ind_vars) - 1) == length(z_names)){
            if (grepl("epm_weibull", fr)){
              n2 <- paste0("k.", seq(1,length(z_names)))  
            } else if (grepl("epm_lognormal", fr) || grepl("epm_normal", fr)){
              n2 <- paste0("stdev.", seq(1,length(z_names)))  
            }
            
          } else { 
            if (grepl("epm_weibull", fr)){
              n2 = "k"
            } else if (grepl("epm_lognormal", fr) || grepl("epm_normal", fr)){
              n2 = "stdev"
            }
          }
          n3 <- "sigma"
          
          rownames(OutLogit) <- c(n1, ind_vars, n2, n3)
          
        } else {
          # Q: will this always be the correct order?
          rownames(OutLogit) <- c(ec_names, p_names)
        }
        
        # save to output folder
        save_table(OutLogit, project = project, mdf[[i]]$mod.name)
        
        if ('all' %in% run) {

          ModelOut[[length(ModelOut) + 1]] <- list(
            name = modOutName, errorExplain = errorExplain,
            OutLogit = OutLogit, optoutput = optoutput, seoutmat2 = seoutmat2,
            MCM = MCM, H1 = H1, choice.table = datamatrix$choice.table,
            params = q2, modTime = mod_time
          )

        } else {

          ModelOut <- list(
            name = modOutName, errorExplain = errorExplain, 
            OutLogit = OutLogit, optoutput = optoutput, seoutmat2 = seoutmat2, 
            MCM = MCM, H1 = H1, choice.table = datamatrix$choice.table, 
            params = q2, modTime = mod_time
          )
        }
        
        # save model output ---- 
        
        # run = 'new': add to mot (unless mot doesn't exist, then create new mot)
        # run = 'all': overwrite existing mot
        # run = select: add new models, replace existing models (unless mot doesn't 
        # exist, then create new mot)
        
        # Note: would be more efficient to save everything after all models have
        # been run, but if function breaks all output is lost. Worth tradeoff?
        
        if(!CV){
          mot_tab_nm <- paste0(project, "ModelOut")  
        } else {
          mot_tab_nm <- paste0(project, "ModelOutCV")  
        }
        
        mot_exists <- table_exists(mot_tab_nm, project)
        
        if ('new' %in% run) {
          
          if (mot_exists) {
            
            mot <- model_out_view(project)
            
            table_remove(mot_tab_nm, project)
            # add new model
            mot[[length(mot) + 1]] <- ModelOut
            
            mot_to_save <- mot
            
          } else {
            # new mot 
            mot_to_save <- list(ModelOut)
          }
          
        } else if ('all' %in% run) {
          
          table_remove(mot_tab_nm, project)
          
          mot_to_save <- ModelOut
          
        } else { # selected models
          
          if (mot_exists) {
            
            mot <- model_out_view(project, CV)
            table_remove(mot_tab_nm, project)
            
            mot_n <- vapply(mot, function(x) x$name, character(1)) 
            
            if (modOutName %in% mot_n) {
              #replace existing model
              mot[[which(mot_n %in% modOutName)]] <- ModelOut
              
            } else {
              # add new model
              mot[[length(mot) + 1]] <- ModelOut
            }
            
            mot_to_save <- mot
            
          } else {
            # new mot
            mot_to_save <- list(ModelOut)
          }
        }
        
        # Save ModelOut table to FSDB
        raw_sql <- paste("INSERT INTO", mot_tab_nm, "VALUES (:data)")
        
        DBI::dbExecute(fishset_db, 
                       paste("CREATE TABLE IF NOT EXISTS", mot_tab_nm, "(data ModelOut)"))
        DBI::dbExecute(fishset_db, raw_sql, 
                       params = list(data = list(serialize(mot_to_save, NULL))))
      } 

      if(isRunning()){
        incProgress(amount = 1/ ((length.exp.names + length(mdf)) * 1.5))
      }
      
    } # End looping through expected catch cases
    
    if(isRunning()){
      incProgress(amount = 1/ ((length.exp.names + length(mdf)) * 1.5))
    }
    
  } # end looping through model choices
    
  # select model app ----
  
  if (select.model == TRUE) {
    
    shiny::runApp(list(
      ui = shiny::basicPage(
        h2("Model Output"),
        DT::DTOutput("mytable"),
        h3(""),
        actionButton("submit", "Save table", style = "color: #fff; background-color: #337ab7; border-color: #2e6da4;display:inline-block;width:12%;text-align: center;"),
        tags$button(
          id = "close",
          type = "button",
          style = "color: #fff; background-color: #FF6347; border-color: #800000; display:inline-block;width:12%;text-align: center;margin-left:10px",
          class = "btn action-button",
          onclick = "setTimeout(function(){window.close();},500);", # close browser
          "Close window"
        )
      ),
      
      server = function(input, output) {
        # helper function for making checkbox
        shinyInput <- function(FUN, len, id, ...) {
          inputs <- character(len)
          for (i in seq_len(len)) {
            inputs[i] <- as.character(FUN(paste0(id, i), label = NULL, ...))
          }
          inputs
        }
        # datatable with checkbox
        output$mytable <- shiny::renderDataTable({
          
            data.frame(t(mft), Select = shinyInput(checkboxInput, nrow(t(mft)), "cbox_"))
          },
          colnames = c("model", "AIC", "AICc", "BIC", "PseudoR2"),
          filter = "top",
          server = FALSE,
          escape = FALSE,
          options = list(
            paging = FALSE,
            preDrawCallback = DT::JS("function() { 
                                 Shiny.unbindAll(this.api().table().node()); }"),
            drawCallback = DT::JS("function() { 
                              Shiny.bindAll(this.api().table().node()); } ")
          )
        )
        # helper function for reading checkbox
        
        shinyValue <- function(id, len) {
          
          unlist(lapply(seq_len(len), function(i) {
            
            value <- input[[paste0(id, i)]]
            
            if (is.null(value)) NA else value
            })
          )
        }
        
        shinyDate <- function(id, len) {
          unlist(lapply(seq_len(len), function(i) {
            # value = input[[paste0(id, i)]]
            # if (is.null(value)) NA else value
            value <- ifelse(input[[paste0(id, i)]] != TRUE, "", as.character(Sys.Date()))
          }))
        }
        
        checkedsave <- reactive(cbind(
          model = colnames(mft), t(mft),
          selected = shinyValue("cbox_", nrow(t(mft))),
          Date = shinyDate("cbox_", nrow(t(mft)))
        ))
        
        
        # When the Submit button is clicked, save the form data
        observeEvent(input$submit, {
          # Connect to the database
          #fishset_db <- DBI::dbConnect(RSQLite::SQLite(), locdatabase(project=project))
          single_sql <- paste0(project, "modelChosen")
          if (DBI::dbExistsTable(fishset_db, single_sql) == FALSE) {
            DBI::dbExecute(fishset_db, paste0("CREATE TABLE ", single_sql, "(model TEXT, AIC TEXT, AICc TEXT, BIC TEXT, PseudoR2 TEXT, selected TEXT, Date TEXT)"))
          }
          # Construct the update query by looping over the data fields
          query <- sprintf(
            "INSERT INTO %s (%s) VALUES %s",
            single_sql,
            paste(names(data.frame(as.data.frame(isolate(checkedsave())))), collapse = ", "),
            paste0("('", matrix(apply(as.data.frame(isolate(checkedsave())), 1, paste, collapse = "','"), ncol = 1), collapse = ",", "')")
          )
          # Submit the update query and disconnect
          DBI::dbGetQuery(fishset_db, query)
          showNotification("Table saved to database")
          
          #Save 
        })
        
        observeEvent(input$close, stopApp())
      }
    ))
  } # end select.model
  
  
  # log ----

  discretefish_subroutine_function <- list()
  discretefish_subroutine_function$functionID <- "discretefish_subroutine"
  discretefish_subroutine_function$args <- list(project, select.model)
  discretefish_subroutine_function$kwargs <- list()
  log_call(project, discretefish_subroutine_function)
  
  single_sql <- paste0(project, "ModelOut", format(Sys.Date(), format = "%Y%m%d"))
  
  if (table_exists(single_sql, project)) {
    # TODO: determine what this block is for, returning parameters?
    out <- 
      unserialize(
        DBI::dbGetQuery(fishset_db, 
                        paste0("SELECT data FROM ", single_sql, " LIMIT 1"))$data[[1]])
  }
}
